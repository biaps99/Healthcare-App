{"version":3,"sources":["webpack:///D:/tese/Bia_final/frontend_bia/node_modules/lodash/_baseValues.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///./customHooks/usePrevious.js","webpack:///D:/tese/Bia_final/frontend_bia/node_modules/lodash/values.js"],"names":["arrayMap","module","exports","object","props","key","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","utils","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_promoteStudyDisplaySet","list","values","searchMethod","listCopy","response","promotedCount","arrayValues","Object","keys","length","seriesInstanceUID","promotedResponse","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","split","forEach","value","index","findIndex","bind","undefined","itemToPromote","splice","data","displaySets","_isQueryParamApplied","applied","seriesInstanceUIDs","validateFilterApplied","arrayToInspect","every","item","some","seriesInstanceUIDStr","validatePromoteApplied","isValid","resultSeries","series","validateMethod","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","createDisplaySets","_addDerivedDisplaySets","_thinStudyData","map","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","studyInstanceUIDs","clearViewportSpecificData","setStudyData","user","useState","isRendered","setIsRendered","error","setError","reload","setReload","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","loadRemaining","Array","isArray","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","log","finally","forceRerender","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","remainingPromises","loadStudies","studiesAccessControl","localStorage","getItem","studiesMap","JSON","parse","isFirstTime","server_url","URL","url","email","req","XMLHttpRequest","open","responseType","setRequestHeader","send","onload","zip","require","flist","blob","loadAsync","files","fileName","file","async","fileBlob","File","type","push","filesToStudies","retrieveParams","splitQueryParameterCalls","enableGoogleCloudAdapter","result_measurements","filter","el","concat","setItem","stringify","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","usePrevious","useEffect","e","includes","purge","content","NotFound","ConnectedViewer","a","style","marginLeft","propTypes","PropTypes","array","isRequired","func","ConnectedViewerRetrieveStudyData","connect","state","auth","OHIF","redux","actions","isActive","active","ownProps","activeServer","servers","find","dispatch","ref","useRef","current","baseValues"],"mappings":"8EAAA,IAAIA,EAAW,EAAQ,KAkBvBC,EAAOC,QANP,SAAoBC,EAAQC,GAC1B,OAAOJ,EAASI,GAAO,SAASC,GAC9B,OAAOF,EAAOE,Q,6zCCIVC,EAA0CC,IAA1CD,kBAAmBE,EAAuBD,IAAvBC,mBACnBC,EAAwDC,IAAxDD,wBAAyBE,EAA+BD,IAA/BC,2BACzBC,EAAyCC,IAAzCD,qBAAsBE,EAAmBD,IAAnBC,eA+BxBC,EAAe,SAACC,EAAOC,EAAeC,EAASC,GACnD,IAAIC,GAAW,EAMf,OAJKD,IACHC,EAAWC,EAAwBL,EAAOC,EAAeC,IAGpDE,GAGHC,EAA0B,SAACL,EAAOC,EAAeC,GACrD,IAxCuBI,EAAMC,EAAQC,EACjCC,EACAC,EACAC,EAEEC,EAmCFR,GAAW,EAIf,GAH0BS,OAAOC,KAAKZ,GAASa,OACE,EAEvB,KAChBC,EAAsBd,EAAtBc,kBAKFC,GAlDeX,EAmDnBL,EAAciB,iBAnDWX,EAoDzBS,EApDiCR,EA+Cb,SAACW,EAAgBC,GACrC,OAAOA,EAAWC,oBAAsBF,GA/CxCV,EAAW,EAAIH,GACfI,EAAW,GACXC,EAAgB,GAEdC,EAAcL,EAAOe,MAAM,MACrBC,SAAQ,SAAAC,GAClB,IAAMC,EAAQhB,EAASiB,UAAUlB,EAAamB,UAAKC,EAAWJ,IAE9D,GAAIC,GAAS,EAAG,KACPI,EADO,EACUpB,EAASqB,OAAOL,EAAO,GADjC,MAEdf,EAASC,GAAiBkB,EAC1BlB,QAIG,CACLP,SAAUO,IAAkBC,EAAYG,OACxCgB,KAAM,GAAF,OAAMrB,EAAN,EAAmBD,MAsCvBT,EAAMgC,YAAcf,EAAiBc,KACrC3B,EAAWa,EAAiBb,SAG9B,OAAOA,GAUH6B,EAAuB,SAACjC,GAA0C,IAAnCE,EAAmC,uDAAzB,GAAIC,EAAqB,uCAC9Da,EAAsBd,EAAtBc,kBAEJkB,GAAU,EAGd,IAAKlB,EACH,OAAOkB,EAET,IAAMC,EAAqBnB,EAAkBM,MAAM,KAE/Cc,EAAwB,WAE1B,GADiBC,EAAetB,SAAWoB,EAAmBpB,OAK9D,OAAOsB,EAAeC,OAAM,SAAAC,GAAI,OAC9BJ,EAAmBK,MACjB,SAAAC,GAAoB,OAAIA,IAAyBF,EAAKlB,yBAKxDqB,EAAyB,WAE3B,IADA,IAAIC,GAAU,EACLlB,EAAQ,EAAGA,EAAQU,EAAmBpB,OAAQU,IAAS,CAC9D,IAAMgB,EAAuBN,EAAmBV,GAC1CmB,EAAeP,EAAeZ,GAEpC,IACGmB,GACDA,EAAavB,oBAAsBoB,EACnC,CACAE,GAAU,EACV,OAGJ,OAAOA,GAtC6D,EAyC5B3C,EAAlC6C,cAzC8D,MAyCrD,GAzCqD,IAyC5B7C,EAArBgC,mBAzCiD,MAyCnC,GAzCmC,EA0ChEK,EAAiBlC,EAAmB0C,EAASb,EAC7Cc,EAAiB3C,EACnBiC,EACAM,EAQJ,OAHER,IAHGG,GAGOS,KAKRC,EAAmB,SAACC,EAAmBC,GAAyB,IAAhBC,EAAgB,uDAAP,GAC7D,IAAIF,EAAJ,CADoE,MAKvBE,EAArCC,KAAMC,OALsD,MAKpC,aALoC,EAMpEA,EAAgB,CACdH,cAIEI,EAAoB,SAACpD,EAAe4C,GACxC,IAAMS,EACJC,IAAiBC,QAAjB,sBACIxD,EAAQC,EAAcwD,UACtBC,EAAiB,IAAIlE,EAAmBqD,EAAQ7C,GAC/BC,EAAc0D,eAAed,EAAOxB,mBAEzDpB,EAAc2D,aAAaf,EAAOxB,kBAAmBqC,GAErDzD,EAAc4D,UAAUH,GAG1BzD,EAAc6D,iCACZR,EACAI,GAGF1D,EAAMgC,YAAc/B,EAAciB,iBAElClB,EAAM+D,mBAAqB9D,EAAc+D,mBAAmB,CAC1DC,SAAUpB,EAAOoB,WAGnBC,EAA4BlE,EAAOC,IAG/BiE,EAA8B,SAAClE,EAAOC,GAAkB,IACpDkE,EAAqBnE,EAArBmE,iBAEHvE,EAAqBwE,IAAID,IAC5BvE,EAAqByE,IAAIpE,IAIvBqE,EAA0B,SAACtE,EAAOC,GACtC,IAAMqD,EACJC,IAAiBC,QAAjB,sBAEGxD,EAAMgC,cACThC,EAAMgC,YAAc/B,EAAcsE,kBAAkBjB,IAGlDtD,EAAM+D,oBACR9D,EAAcuE,uBAAuBxE,EAAM+D,qBAIzCU,EAAiB,SAAAzE,GACrB,MAAO,CACLmE,iBAAkBnE,EAAMmE,iBACxBtB,OAAQ7C,EAAM6C,OAAO6B,KAAI,SAAAnC,GAAI,MAAK,CAChClB,kBAAmBkB,EAAKlB,wBAK9B,SAASsD,EAAT,GAOG,IAeGC,EACAC,EAtBJC,EAMC,EANDA,OACAC,EAKC,EALDA,kBACA5C,EAIC,EAJDA,mBACA6C,EAGC,EAHDA,0BACAC,EAEC,EAFDA,aACAC,EACC,EADDA,KACC,IAEmCC,oBAAS,GAF5C,GAEMC,EAFN,KAEkBC,EAFlB,SAIyBF,oBAAS,GAJlC,GAIMG,EAJN,KAIaC,EAJb,SAK2BJ,oBAAS,GALpC,GAKMK,EALN,KAKcC,EALd,SAM6BN,mBAAS,IANtC,GAMMzF,EANN,KAMegG,EANf,SAOyCP,oBAAS,GAPlD,GAOMQ,EAPN,KAOqBC,EAPrB,KAQKC,EAAkBC,cARvB,EAS0BC,qBAAWC,KAA9BC,iBATP,MASmB,GATnB,IAaGA,EAFFC,iBAAkB/F,OAXnB,SAYCgG,GACEF,EADFE,8BA+CIC,GAAiB,SAACC,EAAanG,EAASoG,GAC5C,GAAIC,MAAMC,QAAQH,IAAgBA,EAAYtF,OAAS,EAAG,CAExD,IAAMrB,EAAU2G,EAAY3B,KAAI,SAAA1E,GAC9BiF,EAAajF,EAAMmE,iBAAkBM,EAAezE,IACpD,IAAMC,EAAgB,IAAIX,EACxBU,EACAA,EAAMmE,kBAyBR,OAtBAG,EAAwBtE,EAAOC,GAC/BiE,EAA4BlE,EAAOC,GAGnC2E,EAAyB5E,EAAMmE,kBAAoBrE,EACjD2G,GAAoBxG,EAAeqG,IAElCI,MAAK,SAAAC,GACAA,IAAWA,EAAOC,YArDX,SAAC5G,EAAOC,EAAeC,GAEzBH,EACfC,EACAC,EACAC,EACAC,IAKA6E,EAA0B,GAG5B,IAAM6B,EAAsB5E,EAC1BjC,EACAE,EACAC,GAGF4C,EACE8D,EACA,qGACAhB,GAGFH,EAAW,GAAD,SAAKhG,GAAL,CAAcM,KA4Bd8G,CAAa9G,EAAOC,EAAeC,MAGtC6G,OAAM,SAAAzB,GACDA,IAAUA,EAAMsB,aAClBrB,EAASD,GACT0B,IAAI1B,MAAMA,OAGb2B,SAAQ,WACPrB,GAAiB,MAGd5F,KAGT0F,EAAWhG,KAITwH,GAAgB,kBAAMxB,GAAW,SAAAhG,GAAO,SAAQA,OAEhD+G,GAAmB,4CAAG,WAAOxG,EAAeqG,GAAtB,qGACDrG,EAAcwD,UAA/B0D,EADkB,EAClBA,aADkB,wDAIpBC,EAJoB,4CAIH,sGAChBD,EAAaE,UADG,iEAEAF,EAAaG,OAFb,UAEfzE,EAFe,OAIhByD,EAJgB,uBAMK,QAApBzD,EAAOoB,UAA0C,OAApBpB,EAAOoB,UACtCZ,EAAkBpD,EAAe4C,GAEnCqE,KATmB,kBAUZE,KAVY,eAYnB/D,EAAkBpD,EAAe4C,GACjCqE,KAbmB,kBAcZE,KAdY,4CAJG,qDAsBpBG,EACJpB,IAAiClG,EAAcuH,iBAC3CC,EAAWlB,MAAMgB,GACpBG,KAAK,MACLhD,IAAI0C,GA1BmB,SA2BMO,QAAQC,IAAIH,GA3BlB,cA2BpBI,EA3BoB,OA4B1BjC,GAAiB,GA5BS,kBA6BnBiC,GA7BmB,4CAAH,wDAgCnBC,GAAW,4CAAG,yHAClB,IACQC,EAAuBC,aAAaC,QAAQ,sBAE9CC,EAAaC,KAAKC,MAAML,GAGR,KAFhBM,EAAcH,EAAWnD,EAAkB,MAGvCuD,EAAa,IAAIC,IAAI,qBAEvBC,EAAM,IAAID,IAAJ,gDACiCxD,EAAkB,GADnD,iBAENG,EAAKuD,OAEPH,IAGEI,EAAM,IAAIC,gBACVC,KAAK,MAAOJ,GAAK,GACrBE,EAAIG,aAAe,OACnBH,EAAII,iBACF,gBADF,cAESd,aAAaC,QAAQ,YAE9BS,EAAIK,OAEJL,EAAIM,OAAS,WACX,IAAMC,EAAMC,EAAQ,IAARA,GACRC,EAAQ,GACRC,EAAOV,EAAIhI,SACfuI,EAAII,UAAUD,GAAM1C,KAApB,4CAAyB,WAAeuC,GAAf,+HACFA,EAAIK,OADF,qDACdC,EADc,oBAEAN,EAAIO,KAAKD,GAAUE,MAAM,QAFzB,OAEjBC,EAFiB,OAGjBF,EAAO,IAAIG,KAAK,CAACD,GAAWH,EAAU,CACxCK,KAAM,oBAERT,EAAMU,KAAKL,GANU,wCAQDM,YAAeX,GARd,QAQjBzJ,EARiB,OAUjBQ,EAAU,GACVc,EACJmB,GAAsBA,EAAmB,GACrC4H,EAAiB,CAACjF,EAAQC,GAE5B/D,IACFd,EAAQc,kBAAoBA,EAExBb,GACF4J,EAAeF,KAAK3J,KAKtB+F,EAAU+D,0BACV/D,EAAUgE,2BAEVF,EAAeF,MAAK,GAGtBhF,EAA0BE,GAAqBjF,EAC7CL,EAAuB,WAAvB,EAA2BsK,IAE1BrD,MAAK,SAAAC,GACJ,GAAIA,IAAWA,EAAOC,WAAY,CAChCvB,GAAc,GAEd,IAAI6E,EAAsBvD,EAAO,GAAG9D,OAAOsH,QAAO,SAChDC,GAEA,MAAuB,OAAhBA,EAAGnG,UAAqC,QAAhBmG,EAAGnG,YAGpCvE,EAAQ,GAAGmD,OAASnD,EAAQ,GAAGmD,OAAOwH,OACpCH,GAGFxK,EAAQ,GAAR,aAA6BiH,EAAO,GAAP,aAC7BjH,EAAQ,GAAR,UAA0BiH,EAAO,GAAP,UAC1BjH,EAAQ,GAAR,SAAyBiH,EAAO,GAAP,SACzBjH,EAAQ,GAAR,YAA4BiH,EAAO,GAAP,YAC5BjH,EAAQ,GAAR,SAAyBiH,EAAO,GAAP,UACzBjH,EAAQ,GAAR,oBACEiH,EAAO,GAAP,oBAEFjH,EAAQ,GAAR,yBACEiH,EAAO,GAAP,yBAEFP,GAAe1G,EAASQ,GAAS,OAGpC6G,OAAM,SAAAzB,GACDA,IAAUA,EAAMsB,aAClBrB,EAASD,GACT0B,IAAI1B,MAAMA,OAIhB4C,EAAWnD,GAAqB,EAChCiD,aAAasC,QACX,qBACAnC,KAAKoC,UAAUrC,IAvEM,4CAAzB,yDA2EuB,IAAhBG,GACT5C,GAAU,GACJvF,EAAU,GACVc,EAAoBmB,GAAsBA,EAAmB,GAC7D4H,EAAiB,CAACjF,EAAQC,GAE5B/D,IACFd,EAAQc,kBAAoBA,EAExBb,GACF4J,EAAeF,KAAK3J,KAKtB+F,EAAU+D,0BACV/D,EAAUgE,2BAEVF,EAAeF,MAAK,GAGtBhF,EAA0BE,GAAqBjF,EAC7CL,EAAuB,WAAvB,EAA2BsK,IAE1BrD,MAAK,SAAAC,GACAA,IAAWA,EAAOC,aACpBvB,GAAc,GAGde,GAAeO,EAAQzG,GAAS,OAGnC6G,OAAM,SAAAzB,GACDA,IAAUA,EAAMsB,aAClBrB,EAASD,GACT0B,IAAI1B,MAAMA,SAIVgD,EAAa,IAAIC,IAAI,qBAEvBC,EAAM,IAAID,IAAJ,iDAENxD,EAAkB,GAFZ,iBAGCG,EAAKuD,OACdH,IAGEI,EAAM,IAAIC,gBACVC,KAAK,MAAOJ,GAAK,GACrBE,EAAIG,aAAe,OACnBH,EAAII,iBACF,gBADF,cAESd,aAAaC,QAAQ,YAE9BS,EAAIK,OAEJL,EAAIM,OAAS,WACX,IAAMC,EAAMC,EAAQ,IAARA,GACRC,EAAQ,GACRC,EAAOV,EAAIhI,SACfuI,EAAII,UAAUD,GAAM1C,KAApB,4CAAyB,WAAeuC,GAAf,+HACFA,EAAIK,OADF,qDACdC,EADc,oBAEAN,EAAIO,KAAKD,GAAUE,MAAM,QAFzB,OAEjBC,EAFiB,OAGjBF,EAAO,IAAIG,KAAK,CAACD,GAAWH,EAAU,CACxCK,KAAM,oBAERT,EAAMU,KAAKL,GANU,wCAQHM,YAAeX,GARZ,QAQnBzJ,EARmB,OAUjBQ,EAAU,GACVc,EACJmB,GAAsBA,EAAmB,GACrC4H,EAAiB,CAACjF,EAAQC,GAE5B/D,IACFd,EAAQc,kBAAoBA,EAExBb,GACF4J,EAAeF,KAAK3J,KAKtB+F,EAAU+D,0BACV/D,EAAUgE,2BAEVF,EAAeF,MAAK,GAGtBhF,EAA0BE,GAAqBjF,EAC7CL,EAAuB,WAAvB,EAA2BsK,IAE1BrD,MAAK,SAAAC,GACJ,GAAIA,IAAWA,EAAOC,WAAY,CAChCvB,GAAc,GAEd,IAAI6E,EAAsBvD,EAAO,GAAG9D,OAAOsH,QAAO,SAChDC,GAEA,MAAuB,OAAhBA,EAAGnG,UAAqC,QAAhBmG,EAAGnG,YAGpCvE,EAAQ,GAAGmD,OAASnD,EAAQ,GAAGmD,OAAOwH,OACpCH,GAGFxK,EAAQ,GAAR,aAA6BiH,EAAO,GAAP,aAG7BjH,EAAQ,GAAR,SAAyBiH,EAAO,GAAP,SACzBjH,EAAQ,GAAR,YAA4BiH,EAAO,GAAP,YAC5BjH,EAAQ,GAAR,SAAyBiH,EAAO,GAAP,UACzBjH,EAAQ,GAAR,oBACEiH,EAAO,GAAP,oBAEFjH,EAAQ,GAAR,yBACEiH,EAAO,GAAP,yBAEFP,GAAe1G,EAASQ,GAAS,OAGpC6G,OAAM,SAAAzB,GACDA,IAAUA,EAAMsB,aAClBrB,EAASD,GACT0B,IAAI1B,MAAMA,OAIhB4C,EAAWnD,IAAsB,EACjCiD,aAAasC,QACX,qBACAnC,KAAKoC,UAAUrC,IAxEM,4CAAzB,yDA6EJ,MAAO5C,GACHA,IACFC,EAASD,GACT0B,IAAI1B,MAAMA,IAtPI,2CAAH,qDA2PXkF,GAA2BC,uBAAY,WAC3C,IAAK,IAAI1F,KAAqBF,EACxB,WAAYA,EAA0BE,IACxCF,EAA0BE,GAAmB2F,SAIjD,IAAK,IAAI3F,KAAqBH,EACxB,WAAYA,EAAyBG,KACvCH,EAAyBG,GAAmB2F,SAC5C/K,EAA2BoF,GAC3BnF,EAAqB+K,OAAO5F,MAG/B,CAACH,EAA0BC,IAExB+F,GAAwBC,YAAY9F,GAwB1C,GAtBA+F,qBAAU,aAENF,IACAA,GAAsBtI,OAAM,SAAAyI,GAAC,OAAIhG,EAAkBiG,SAASD,SAI5DnL,EAAqBqL,QACrBT,QAED,CAACI,GAAuBJ,GAA0BzF,IAErD+F,qBAAU,WAKR,OAJAlG,EAA2B,GAC3BC,EAA4B,GAC5BiD,KAEO,WACL0C,QAED,IAEClF,EAAO,CACT,IAAM4F,GAAU/C,KAAKoC,UAAUjF,GAC/B,OAAI4F,GAAQF,SAAS,QAAUE,GAAQF,SAAS,aACvC,kBAACG,EAAA,EAAD,MAGF,kBAACA,EAAA,EAAD,CAAUlI,QAAQ,kCAG3B,OACE,kBAAC,WAAD,KACGmC,EACC,kBAACgG,EAAA,EAAD,CACE1L,QAASA,EACTiG,cAAeA,EACfZ,kBAAmBrF,GAAWA,EAAQgF,KAAI,SAAA2G,GAAC,OAAIA,EAAElH,oBACjDqB,OAAQA,IAGV,kBAAC,WAAD,KACE,wBAAI8F,MAAO,CAAEC,WAAY,SAAW,gBAO9C5G,EAAwB6G,UAAY,CAClCzG,kBAAmB0G,IAAUC,MAAMC,WACnCxJ,mBAAoBsJ,IAAUC,MAC9B5G,OAAQ2G,IAAUtM,OAClB6F,0BAA2ByG,IAAUG,KAAKD,WAC1C1G,aAAcwG,IAAUG,KAAKD,WAC7BzG,KAAMuG,IAAUtM,QAGlB,IASe0M,EAL0BC,aAJjB,SAAAC,GAAK,MAAK,CAChC7G,KAAM6G,EAAMC,KAAK9G,QAKjB,KAFuC4G,CAGvCnH,G,QC3qBkDsH,EAAKC,MAAMC,QAAvDnH,E,EAAAA,0BAA2BC,E,EAAAA,aAC7BmH,EAAW,SAAAf,GAAC,OAAiB,IAAbA,EAAEgB,QAoBlBR,EAAmCC,aAlBjB,SAACC,EAAOO,GAC9B,IAAMC,EAAeR,EAAMS,QAAQA,QAAQC,KAAKL,GAEhD,MAAO,CACLtH,OAAQwH,EAASxH,QAAUyH,MAGJ,SAAAG,GACzB,MAAO,CACLzH,aAAc,SAACd,EAAkBpC,GAC/B2K,EAASzH,EAAad,EAAkBpC,KAE1CiD,0BAA2B,WACzB0H,EAAS1H,SAK0B8G,CAGvCnH,GAEakH,O,kCC9Bf,6CACe,SAAShB,EAAYrJ,GAClC,IAAMmL,EAAMC,mBAKZ,OAJA9B,qBAAU,WACR6B,EAAIE,QAAUrL,IACb,CAACA,IAEGmL,EAAIE,U,qBCPb,IAAIC,EAAa,EAAQ,MACrBhM,EAAO,EAAQ,KAgCnB7B,EAAOC,QAJP,SAAgBC,GACd,OAAiB,MAAVA,EAAiB,GAAK2N,EAAW3N,EAAQ2B,EAAK3B","file":"1.bundle.57197f3fce3b4e7e87be.js","sourcesContent":["var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","import React, {\n  useState,\n  Fragment,\n  useEffect,\n  useContext,\n  useCallback,\n} from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from '../App.js';\nimport { useSnackbarContext } from '@ohif/ui';\nimport AppContext from '../context/AppContext';\nimport NotFound from '../routes/NotFound';\nimport filesToStudies from '../lib/filesToStudies';\nimport { connect } from 'react-redux';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, makeCancelable } = utils;\n\nconst _promoteToFront = (list, values, searchMethod) => {\n  let listCopy = [...list];\n  let response = [];\n  let promotedCount = 0;\n\n  const arrayValues = values.split(',');\n  arrayValues.forEach(value => {\n    const index = listCopy.findIndex(searchMethod.bind(undefined, value));\n\n    if (index >= 0) {\n      const [itemToPromote] = listCopy.splice(index, 1);\n      response[promotedCount] = itemToPromote;\n      promotedCount++;\n    }\n  });\n\n  return {\n    promoted: promotedCount === arrayValues.length,\n    data: [...response, ...listCopy],\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.SeriesInstanceUID === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n\n  let applied = true;\n  // skip in case no filter or no toast manager\n\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n  const seriesInstanceUIDs = seriesInstanceUID.split(',');\n\n  let validateFilterApplied = () => {\n    const sameSize = arrayToInspect.length === seriesInstanceUIDs.length;\n    if (!sameSize) {\n      return;\n    }\n\n    return arrayToInspect.every(item =>\n      seriesInstanceUIDs.some(\n        seriesInstanceUIDStr => seriesInstanceUIDStr === item.SeriesInstanceUID\n      )\n    );\n  };\n\n  let validatePromoteApplied = () => {\n    let isValid = true;\n    for (let index = 0; index < seriesInstanceUIDs.length; index++) {\n      const seriesInstanceUIDStr = seriesInstanceUIDs[index];\n      const resultSeries = arrayToInspect[index];\n\n      if (\n        !resultSeries ||\n        resultSeries.SeriesInstanceUID !== seriesInstanceUIDStr\n      ) {\n        isValid = false;\n        break;\n      }\n    }\n    return isValid;\n  };\n\n  const { series = [], displaySets = [] } = study;\n  const arrayToInspect = isFilterStrategy ? series : displaySets;\n  const validateMethod = isFilterStrategy\n    ? validateFilterApplied\n    : validatePromoteApplied;\n\n  if (!arrayToInspect) {\n    applied = false;\n  } else {\n    applied = validateMethod();\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => {} } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\n  if (existingSeries) {\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\n  } else {\n    studyMetadata.addSeries(seriesMetadata);\n  }\n\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata\n  );\n\n  study.displaySets = studyMetadata.getDisplaySets();\n\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\n    Modality: series.Modality,\n  });\n\n  _updateStudyMetadataManager(study, studyMetadata);\n};\n\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\n  const { StudyInstanceUID } = study;\n\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n  }\n\n  if (study.derivedDisplaySets) {\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\n  }\n};\n\nconst _thinStudyData = study => {\n  return {\n    StudyInstanceUID: study.StudyInstanceUID,\n    series: study.series.map(item => ({\n      SeriesInstanceUID: item.SeriesInstanceUID,\n    })),\n  };\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUIDs,\n  seriesInstanceUIDs,\n  clearViewportSpecificData,\n  setStudyData,\n  user,\n}) {\n  // hooks\n  const [isRendered, setIsRendered] = useState(false);\n\n  const [error, setError] = useState(false);\n  const [reload, setReload] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const {\n    filterQueryParam: isFilterStrategy = false,\n    maxConcurrentMetadataRequests,\n  } = appConfig;\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not totally applied. It might be using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filters.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters, loadRemaining) => {\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studies = studiesData.map(study => {\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.StudyInstanceUID\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateStudyMetadataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\n          loadRemainingSeries(studyMetadata, loadRemaining)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(error);\n              log.error(error);\n            }\n          })\n          .finally(() => {\n            setIsStudyLoaded(true);\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const forceRerender = () => setStudies(studies => [...studies]);\n\n  const loadRemainingSeries = async (studyMetadata, loadRemaining) => {\n    const { seriesLoader } = studyMetadata.getData();\n    if (!seriesLoader) return;\n\n    const loadNextSeries = async () => {\n      if (!seriesLoader.hasNext()) return;\n      const series = await seriesLoader.next();\n\n      if (!loadRemaining) {\n        // false\n        if (series.Modality === 'SEG' || series.Modality === 'SR') {\n          _addSeriesToStudy(studyMetadata, series);\n        }\n        forceRerender();\n        return loadNextSeries();\n      } else {\n        _addSeriesToStudy(studyMetadata, series);\n        forceRerender();\n        return loadNextSeries();\n      }\n    };\n\n    const concurrentRequestsAllowed =\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\n    const promises = Array(concurrentRequestsAllowed)\n      .fill(null)\n      .map(loadNextSeries);\n    const remainingPromises = await Promise.all(promises);\n    setIsStudyLoaded(true);\n    return remainingPromises;\n  };\n\n  const loadStudies = async () => {\n    try {\n      const studiesAccessControl = localStorage.getItem('studyAccessControl');\n\n      let studiesMap = JSON.parse(studiesAccessControl);\n      let isFirstTime = studiesMap[studyInstanceUIDs[0]];\n\n      if (isFirstTime === 0) {\n        const server_url = new URL('http://localhost/');\n\n        let url = new URL(\n          `api/image_decrypt/?hasPerm=true&study=${studyInstanceUIDs[0]}&user=${\n            user.email\n          }`,\n          server_url\n        );\n\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.responseType = 'blob';\n        req.setRequestHeader(\n          'Authorization',\n          `JWT ${localStorage.getItem('access')}`\n        );\n        req.send();\n\n        req.onload = () => {\n          const zip = require('jszip')();\n          let flist = [];\n          var blob = req.response;\n          zip.loadAsync(blob).then(async function(zip) {\n            for (let fileName in zip.files) {\n              var fileBlob = await zip.file(fileName).async('blob');\n              var file = new File([fileBlob], fileName, {\n                type: 'application/dcm',\n              });\n              flist.push(file);\n            }\n            const studies = await filesToStudies(flist);\n\n            const filters = {};\n            const seriesInstanceUID =\n              seriesInstanceUIDs && seriesInstanceUIDs[0];\n            const retrieveParams = [server, studyInstanceUIDs];\n\n            if (seriesInstanceUID) {\n              filters.seriesInstanceUID = seriesInstanceUID;\n              // Query param filtering controlled by appConfig property\n              if (isFilterStrategy) {\n                retrieveParams.push(filters);\n              }\n            }\n\n            if (\n              appConfig.splitQueryParameterCalls ||\n              appConfig.enableGoogleCloudAdapter\n            ) {\n              retrieveParams.push(true);\n            }\n\n            cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n              retrieveStudiesMetadata(...retrieveParams)\n            )\n              .then(result => {\n                if (result && !result.isCanceled) {\n                  setIsRendered(true);\n\n                  let result_measurements = result[0].series.filter(function(\n                    el\n                  ) {\n                    return el.Modality === 'SR' || el.Modality === 'SEG';\n                  });\n\n                  studies[0].series = studies[0].series.concat(\n                    result_measurements\n                  );\n\n                  studies[0]['seriesLoader'] = result[0]['seriesLoader'];\n                  studies[0]['seriesMap'] = result[0]['seriesMap'];\n                  studies[0]['wadoRoot'] = result[0]['wadoRoot'];\n                  studies[0]['wadoUriRoot'] = result[0]['wadoUriRoot'];\n                  studies[0]['qidoRoot'] = result[0]['qidoRoots'];\n                  studies[0]['FrameOfReferenceUID'] =\n                    result[0]['FrameOfReferenceUID'];\n                  //ReferencedSeriesSequence\n                  studies[0]['ReferencedSeriesSequence'] =\n                    result[0]['ReferencedSeriesSequence'];\n\n                  processStudies(studies, filters, true);\n                }\n              })\n              .catch(error => {\n                if (error && !error.isCanceled) {\n                  setError(error);\n                  log.error(error);\n                }\n              });\n            //setReload(true);\n            studiesMap[studyInstanceUIDs] = 1; //not first time anymore.\n            localStorage.setItem(\n              'studyAccessControl',\n              JSON.stringify(studiesMap)\n            );\n          });\n        };\n      } else if (isFirstTime === 1) {\n        setReload(false);\n        const filters = {};\n        const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\n        const retrieveParams = [server, studyInstanceUIDs];\n\n        if (seriesInstanceUID) {\n          filters.seriesInstanceUID = seriesInstanceUID;\n          // Query param filtering controlled by appConfig property\n          if (isFilterStrategy) {\n            retrieveParams.push(filters);\n          }\n        }\n\n        if (\n          appConfig.splitQueryParameterCalls ||\n          appConfig.enableGoogleCloudAdapter\n        ) {\n          retrieveParams.push(true);\n        }\n\n        cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n          retrieveStudiesMetadata(...retrieveParams)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              setIsRendered(true);\n              //console.log(result);\n\n              processStudies(result, filters, true);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(error);\n              log.error(error);\n            }\n          });\n      } else {\n        const server_url = new URL('http://localhost/');\n\n        let url = new URL(\n          `api/image_decrypt/?hasPerm=false&study=${\n            studyInstanceUIDs[0]\n          }&user=${user.email}`,\n          server_url\n        );\n\n        let req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.responseType = 'blob';\n        req.setRequestHeader(\n          'Authorization',\n          `JWT ${localStorage.getItem('access')}`\n        );\n        req.send();\n\n        req.onload = () => {\n          const zip = require('jszip')();\n          let flist = [];\n          var blob = req.response;\n          zip.loadAsync(blob).then(async function(zip) {\n            for (let fileName in zip.files) {\n              var fileBlob = await zip.file(fileName).async('blob');\n              var file = new File([fileBlob], fileName, {\n                type: 'application/dcm',\n              });\n              flist.push(file);\n            }\n            let studies = await filesToStudies(flist);\n\n            const filters = {};\n            const seriesInstanceUID =\n              seriesInstanceUIDs && seriesInstanceUIDs[0];\n            const retrieveParams = [server, studyInstanceUIDs];\n\n            if (seriesInstanceUID) {\n              filters.seriesInstanceUID = seriesInstanceUID;\n              // Query param filtering controlled by appConfig property\n              if (isFilterStrategy) {\n                retrieveParams.push(filters);\n              }\n            }\n\n            if (\n              appConfig.splitQueryParameterCalls ||\n              appConfig.enableGoogleCloudAdapter\n            ) {\n              retrieveParams.push(true);\n            }\n\n            cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n              retrieveStudiesMetadata(...retrieveParams)\n            )\n              .then(result => {\n                if (result && !result.isCanceled) {\n                  setIsRendered(true);\n\n                  let result_measurements = result[0].series.filter(function(\n                    el\n                  ) {\n                    return el.Modality === 'SR' || el.Modality === 'SEG';\n                  });\n\n                  studies[0].series = studies[0].series.concat(\n                    result_measurements\n                  );\n\n                  studies[0]['seriesLoader'] = result[0]['seriesLoader'];\n\n                  //studies[0]['seriesMap'] = result[0]['seriesMap'];\n                  studies[0]['wadoRoot'] = result[0]['wadoRoot'];\n                  studies[0]['wadoUriRoot'] = result[0]['wadoUriRoot'];\n                  studies[0]['qidoRoot'] = result[0]['qidoRoots'];\n                  studies[0]['FrameOfReferenceUID'] =\n                    result[0]['FrameOfReferenceUID'];\n\n                  studies[0]['ReferencedSeriesSequence'] =\n                    result[0]['ReferencedSeriesSequence'];\n\n                  processStudies(studies, filters, false);\n                }\n              })\n              .catch(error => {\n                if (error && !error.isCanceled) {\n                  setError(error);\n                  log.error(error);\n                }\n              });\n            //setReload(true);\n            studiesMap[studyInstanceUIDs] = -1;\n            localStorage.setItem(\n              'studyAccessControl',\n              JSON.stringify(studiesMap)\n            );\n          });\n        };\n      }\n    } catch (error) {\n      if (error) {\n        setError(error);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = useCallback(() => {\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\n      }\n    }\n\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\n        deleteStudyMetadataPromise(studyInstanceUIDs);\n        studyMetadataManager.remove(studyInstanceUIDs);\n      }\n    }\n  }, [cancelableSeriesPromises, cancelableStudiesPromises]);\n\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\n\n  useEffect(() => {\n    const hasStudyInstanceUIDsChanged = !(\n      prevStudyInstanceUIDs &&\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\n    );\n\n    if (hasStudyInstanceUIDsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\n\n  useEffect(() => {\n    cancelableSeriesPromises = {};\n    cancelableStudiesPromises = {};\n    loadStudies();\n\n    return () => {\n      purgeCancellablePromises();\n    };\n  }, []);\n\n  if (error) {\n    const content = JSON.stringify(error);\n    if (content.includes('404') || content.includes('NOT_FOUND')) {\n      return <NotFound />;\n    }\n\n    return <NotFound message=\"Failed to retrieve study data\" />;\n  }\n\n  return (\n    <Fragment>\n      {isRendered ? (\n        <ConnectedViewer\n          studies={studies}\n          isStudyLoaded={isStudyLoaded}\n          studyInstanceUIDs={studies && studies.map(a => a.StudyInstanceUID)}\n          reload={reload}\n        />\n      ) : (\n        <Fragment>\n          <h3 style={{ marginLeft: '20px' }}>{'Loading...'}</h3>\n        </Fragment>\n      )}\n    </Fragment>\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUIDs: PropTypes.array.isRequired,\n  seriesInstanceUIDs: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n  setStudyData: PropTypes.func.isRequired,\n  user: PropTypes.object,\n};\n\nconst mapStateToProps = state => ({\n  user: state.auth.user,\n});\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  null\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\n\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n\n  return {\n    server: ownProps.server || activeServer,\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    setStudyData: (StudyInstanceUID, data) => {\n      dispatch(setStudyData(StudyInstanceUID, data));\n    },\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n"],"sourceRoot":""}